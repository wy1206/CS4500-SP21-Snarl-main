#! /usr/bin/python3
import sys
import random
import math
from Snarl.src.tile import Tile
from Snarl.src.player import Player
from Snarl.src.key import Key
from Snarl.src.exit import Exit
from Snarl.src.adversary import Adversary


class GameState:
    level_num = -1
    curr_level = -1
    board = [[]]
    turn = -1
    unlocked = False
    players = []
    adversaries = []
    # the players and adversaries are all 'character'.
    characters = []
    key = None
    exit = None
    board_col = -1
    board_row = -1
    input_level = None
    placeable_tiles = []
    zombie_placeable_tiles = []

    def __init__(self, curr_level, turn, unlocked, players, adversaries, level_num):
        """
        The GameState ensure the players and adversaries to have valid moves on the map and it tracks the progress
         of game.

        Arguments:
            curr_level: indicating the nth level players are in, determine whether the game is over.
            turn: a flag representing whose turn currently is, switched based on the interaction between players and
             the game manager.
            unlocked: a boolean representing whether the key is picked up and the exit is open.
            players: a list of object Player.
            adversaries: a list of object Adversary.
            level_num: the total number of levels in the game
        """
        self.curr_level = curr_level
        self.turn = turn
        self.unlocked = unlocked
        self.players = players
        self.adversaries = adversaries

        self.level_num = level_num

    def init_map(self, sample_level):
        """
        initialize the game with the given level layout
        :param sample_level: the target level to be initialized
        :return: none
        """
        self.input_level = sample_level

        self.placeable_tiles = []
        self.zombie_placeable_tiles = []

        # variables used to store all x y dimensions and generate the 2D array of the whole level
        all_x = []
        all_y = []
        all_wps_x = [0]
        all_wps_y = [0]
        top_left_room = None
        bottom_right_room = None
        room_pos = []

        for room in sample_level.rooms:
            all_x.append(room.position[0] + room.width - 1)
            all_y.append(room.position[1] + room.height - 1)
            # the top left room
            room_pos.append(room.position[0] + room.position[1])
            if min(room_pos) == room.position[0] + room.position[1]:
                top_left_room = room
            if max(room_pos) == room.position[0] + room.position[1]:
                bottom_right_room = room

        for hallway in sample_level.hallways:
            for point in hallway.waypoints:
                all_wps_x.append(point[0])
                all_wps_y.append(point[1])

        self.board_col = max(max(all_x), max(all_wps_x)) + 1
        self.board_row = max(max(all_y), max(all_wps_y)) + 1

        # the 2D array generated by using the given size calculated
        board = [[None for i in range(self.board_col)] for j in range(self.board_row)]

        def apply_waypoint(p1, p2):
            """Takes two Points in a same row or same column and add hallways between those two point
             on board.

            Arguments:
                p1(Point): the start point of the drawing process.
                p2(Point): the finish point of the drawing process.

            Returns:
                None

            :except: IndexError When the characters are not enough.

            """

            # the current tile used for tracking position
            temp_tile_pos = (min(p1[0], p2[0]), min(p1[1], p2[1]))

            if abs(p1[0] - p2[0]) == 1 or abs(p1[1] - p2[1]) == 1:
                board[p1[1]][p1[0]] = Tile("hallway", [])
                board[p2[1]][p2[0]] = Tile("hallway", [])

            # applying tiles for the hallway vertically
            board[temp_tile_pos[1]][temp_tile_pos[0]] = Tile("hallway", [])

            if p1[0] == p2[0]:
                for m in range(abs(p1[1] - p2[1])):
                    temp_tile_pos = (temp_tile_pos[0], temp_tile_pos[1] + 1)
                    board[temp_tile_pos[1]][temp_tile_pos[0]] = Tile("hallway", [])
            # applying tiles for the hallway vertically
            if p1[1] == p2[1]:
                for n in range(abs(p1[0] - p2[0])):
                    temp_tile_pos = (temp_tile_pos[0] + 1, temp_tile_pos[1])
                    board[temp_tile_pos[1]][temp_tile_pos[0]] = Tile("hallway", [])

        # use the position of two doors and list of waypoint positions stored in hallway and pass them into the helper
        # function apply_waypoint
        for hallway in sample_level.hallways:

            if len(hallway.waypoints) == 0:
                apply_waypoint(hallway.door1, hallway.door2)
            else:
                # store the current tile in progress and all the visited tiles
                visited = [hallway.door1]
                current_tile_pos = hallway.door1
                while True:
                    for waypoint in hallway.waypoints:
                        if (waypoint[0] == current_tile_pos[0] or waypoint[1] == current_tile_pos[1]) and waypoint not \
                                in visited:
                            apply_waypoint(current_tile_pos, waypoint)
                            visited.append(waypoint)
                            current_tile_pos = waypoint
                    if len(visited) > len(hallway.waypoints):
                        apply_waypoint(current_tile_pos, hallway.door2)
                        break

        # add all rooms on the board
        try:
            for room in sample_level.rooms:
                for tile in room.non_wall_tiles:
                    # add player to the top left-most room
                    if sample_level.key_pos not in room.non_wall_tiles \
                            and sample_level.exit_pos not in room.non_wall_tiles:
                        self.placeable_tiles.append(tile)
                        if tile not in room.doors:
                            self.zombie_placeable_tiles.append(tile)
                    board[tile[1]][tile[0]] = Tile("floor", [])
                for door in room.doors:
                    board[door[1]][door[0]] = Tile("door", [])
        except IndexError:
            print("not enough space for character!")

        # add all walls on the board
        for room in sample_level.rooms:
            for i in range(room.position[0], room.position[0] + room.width):
                for j in range(room.position[1], room.position[1] + room.height):
                    if board[j][i] is None:
                        board[j][i] = Tile("wall", [])

        # add all voids on the board, add key & exit to the tile

        for i in range(self.board_col):
            for j in range(self.board_row):
                if board[j][i] is None:
                    board[j][i] = Tile("void", [])
                # if no key is given
                try:
                    if j == sample_level.key_pos[1] and i == sample_level.key_pos[0]:
                        temp_key = Key((i, j))
                        board[j][i].occupied_by.append(temp_key)
                        self.key = temp_key
                except TypeError:
                    pass
                if j == sample_level.exit_pos[1] and i == sample_level.exit_pos[0]:
                    temp_exit = Exit((i, j))
                    board[j][i].occupied_by.append(temp_exit)
                    self.exit = temp_exit

        self.unlocked = False

        for player in self.players:
            player.expelled = False
        self.board = board

    def init_character(self):
        """
        The function whih initialize the character's information(position, name)
        :return: None
        :except: IndexError, ValueError when the space is not enough for the characters.
        """
        for player in self.players:
            player.expelled = False
        # initializing zombies and ghosts
        zombie_num = math.floor(self.curr_level / 2) + 1
        ghost_num = math.floor((self.curr_level - 1) / 2)

        self.adversaries = []
        for i in range(0, zombie_num):
            temp_zombie = Adversary("dummy" + str(random.randint(0, 999)), "zombie", self.input_level)
            self.adversaries.append(temp_zombie)

        for i in range(0, ghost_num):
            temp_ghost = Adversary("dummy" + str(random.randint(0, 999)), "ghost", self.input_level)
            self.adversaries.append(temp_ghost)

        self.characters = self.players + self.adversaries

        # placing character on board
        try:
            for player in self.players:
                placement = self.placeable_tiles.pop(random.randrange(len(self.placeable_tiles)))
                self.zombie_placeable_tiles.remove(placement)
                self.board[placement[1]][placement[0]].occupied_by.append(player)
                player.position = placement

            for adv in self.adversaries:
                while True:
                    if adv.adversary_type == "zombie":
                        placement = self.zombie_placeable_tiles.pop(random.randrange(len(self.zombie_placeable_tiles)))
                    else:
                        placement = self.placeable_tiles.pop(random.randrange(len(self.placeable_tiles)))
                    if len(self.board[placement[1]][placement[0]].occupied_by) == 0:
                        self.board[placement[1]][placement[0]].occupied_by.append(adv)
                        adv.position = placement
                        break

        except (IndexError, ValueError):
            raise Exception("invalid level! Not enough space to put characters.")

    def switch_turn(self):
        """
        switch the turn to the subsequent flag and notify the client

        :param: none

        :return: int (the flag representing the player for the next movement)
        """

        # check if when to reset index to be 0
        self.turn = self.turn + 1 if self.turn < len(self.characters) - 1 else 0
        if self.turn < len(self.players) and self.players[self.turn].expelled:
            self.switch_turn()

    def advance_level(self, level):
        """
        advanced to next level and reinitialize the board

        :param level: [[Tile]] representing the next level

        :return: none
        """
        self.curr_level += 1
        self.init_map(level)
        self.init_character()
        self.turn = 0

    def move(self, from_pos, to_pos):
        """
        :param from_pos: a Point represent starting position of move
        :param to_pos: a Point represent destination of move
        :return: none
        """
        # Rule checker will check validity before move is called
        character = None
        for char in self.board[from_pos[1]][from_pos[0]].occupied_by:
            if isinstance(char, Player) or isinstance(char, Adversary):
                character = char
                break
        target = self.board[to_pos[1]][to_pos[0]].occupied_by
        if len(target) != 0:
            if isinstance(character, Player):
                for obj in target:
                    if isinstance(obj, Key):
                        self.unlocked = True
                        for a_exit in self.board[self.exit.position[1]][self.exit.position[0]].occupied_by:
                            if isinstance(a_exit, Exit):
                                a_exit.exit_unlocked = True
                        self.board[to_pos[1]][to_pos[0]].occupied_by.remove(obj)
                    if isinstance(obj, Adversary):
                        self.board[from_pos[1]][from_pos[0]].occupied_by.remove(character)
                        self.players[self.turn].expelled = True
                        for player in self.players:
                            if player.player_name == character.player_name:
                                player.position = to_pos
                        return
                for player in self.players:
                    if player.player_name == character.player_name:
                        player.position = to_pos
            if isinstance(character, Adversary):
                for obj in target:
                    if isinstance(obj, Player):
                        self.board[to_pos[1]][to_pos[0]].occupied_by.remove(obj)
                        for player in self.players:
                            if player.player_name == obj.player_name:
                                player.expelled = True
                for adv in self.adversaries:
                    if adv.adversary_name == character.adversary_name:
                        adv.position = to_pos

        self.board[to_pos[1]][to_pos[0]].occupied_by.append(character)
        self.board[from_pos[1]][from_pos[0]].occupied_by.remove(character)

    def get_state(self, player_pos, adv_pos, exit_status):
        """

        :param player_pos: list of player's position, the index correspond to the field 'players'
        :param adv_pos: list of adversaries' position, the index correspond to the field 'adversaries'
        :param exit_status: the status of exit
        :return: the intermediate state with given parameters
        """
        for i in range(self.board_col):
            for j in range(self.board_row):
                for obj in self.board[j][i].occupied_by:
                    if isinstance(obj, Player) or isinstance(obj, Adversary):
                        self.board[j][i].occupied_by.remove(obj)

        # place players and adversaries to the corresponding position
        player_index = 0
        adv_index = 0
        for player in self.players:
            self.board[player_pos[player_index][1]][player_pos[player_index][0]].occupied_by.append(player)
            player_index += 1
        for adv in self.adversaries:
            self.board[adv_pos[adv_index][1]][adv_pos[adv_index][0]].occupied_by.append(adv)
            adv_index += 1
        self.unlocked = exit_status
        return self
